# Task ID: 5
# Title: Implement Content Parser with HTML to Markdown Conversion
# Status: pending
# Dependencies: 4
# Priority: high
# Description: Create the content parser module to convert HTML emails to Markdown
# Details:
Create src/content_parser.py that integrates the html2text library. Implement parse_html_content(html_body: str, plain_text_body: str) -> (parsed_content: str, is_fallback: bool) function that converts HTML to Markdown, falls back to plain text on failure, and enforces the 20,000 character limit. Add proper error handling and logging.

# Test Strategy:
Test with various HTML inputs including complex formatting, malformed HTML, and edge cases. Verify character limit enforcement and fallback mechanism.

# Subtasks:
## 1. Set up content_parser module and html2text dependency [pending]
### Dependencies: None
### Description: Create the content parser module file and ensure the html2text library is available and imported correctly.
### Details:
1) Add html2text to the project dependencies (e.g., pyproject.toml/requirements.txt) so it is installed with the application.[1][4] 2) Create src/content_parser.py if it does not exist. 3) In src/content_parser.py, import html2text (either using the functional API html2text.html2text or the HTML2Text class, depending on configuration needs).[1][6][7] 4) Define the public function signature parse_html_content(html_body: str, plain_text_body: str) -> tuple[str, bool] (or -> (str, bool) for older Python) as a stub that currently just returns the plain_text_body and a fallback flag placeholder.

## 2. Implement HTML to Markdown conversion using html2text [pending]
### Dependencies: 5.1
### Description: Use html2text to convert HTML email bodies to Markdown, encapsulated in a helper inside the content_parser module.
### Details:
1) Inside src/content_parser.py, create a private helper function _html_to_markdown(html_body: str) -> str. 2) Instantiate html2text.HTML2Text() so you can configure behavior (e.g., body_width = 0 to avoid wrapping, configure link handling, etc.).[1][7][5][8] 3) Use h.handle(html_body) on the HTML2Text instance to produce the Markdown string.[1][6][7] 4) Ensure the helper returns the converted text as a Python str. 5) Add basic normalization such as stripping leading/trailing whitespace if desired, but do not yet implement limit enforcement or fallback logic in this helper.

## 3. Add error handling and fallback to plain text [pending]
### Dependencies: 5.2
### Description: Ensure parse_html_content uses the HTML conversion with robust error handling and falls back to the plain text body when needed.
### Details:
1) In parse_html_content, wrap the call to _html_to_markdown in a try/except block catching broad exceptions (e.g., Exception) to handle unexpected errors from html2text.[1][6] 2) If html_body is missing, empty, or only whitespace, skip HTML conversion and directly use plain_text_body as the output content, setting is_fallback = True. 3) If _html_to_markdown raises an exception, log the error (to be implemented in the logging subtask) and use plain_text_body as the output content with is_fallback = True. 4) If HTML conversion succeeds and produces a non-empty string, set parsed_content to that value and is_fallback = False. 5) If HTML conversion technically succeeds but returns an empty or whitespace-only string, treat this as a failed conversion and fall back to plain_text_body with is_fallback = True.

## 4. Enforce 20,000-character limit on parsed content [pending]
### Dependencies: 5.3
### Description: Apply a hard length limit of 20,000 characters to the returned content, after conversion and fallback handling.
### Details:
1) After determining parsed_content (whether from HTML or plain_text fallback) and before returning from parse_html_content, check len(parsed_content). 2) If the string exceeds 20_000 characters, truncate it to parsed_content[:20_000]. 3) Decide and document that truncation does not change the is_fallback flag: if content came from HTML and was truncated, is_fallback remains False; if it came from plain_text, is_fallback remains True. 4) Optionally, avoid expensive length recomputations by only slicing when len(parsed_content) > 20_000. 5) Keep the limit logic isolated inside parse_html_content so callers always receive content that respects the size constraint.

## 5. Integrate logging and add basic tests for content_parser [pending]
### Dependencies: 5.4
### Description: Add structured logging for errors and key decision branches, and create tests to validate conversion, fallback, and limit behavior.
### Details:
1) Use the standard logging module (or the projectâ€™s logging wrapper) in src/content_parser.py, creating a module-level logger via logging.getLogger(__name__). 2) Log at debug/info level when HTML conversion is attempted and whether it is used or skipped (e.g., missing HTML, empty HTML). 3) Log at warning/error level when HTML conversion fails and the parser falls back to plain_text_body, including exception details. 4) Log when content is truncated due to exceeding 20,000 characters, ideally including original length and truncated length. 5) Create unit tests (e.g., in tests/test_content_parser.py) that cover: a) successful HTML-to-Markdown conversion with is_fallback = False, b) missing/empty HTML with fallback to plain text and is_fallback = True, c) forced exception in _html_to_markdown to verify error logging and fallback, d) enforcement of the 20,000-character limit for both HTML-derived and plain-text-derived content.

## 6. Final stage: Validate tests, update documentation, review rules, mark done, and commit [pending]
### Dependencies: 5.1, 5.2, 5.3, 5.4, 5.5
### Description: MANDATORY final stage: Run tests, update documentation, review for rule learnings, mark task done in Task Master, and commit all changes.
### Details:
1) Run full test suite: pytest -v and ensure all tests pass (new and existing). Fix any failing tests before proceeding.
2) Update/create module documentation in docs/ directory following documentation.mdc guidelines. Update docs/MAIN_DOCS.md if adding new documentation. Reference relevant PDD sections.
3) Review code for patterns that should be captured in rules (see .cursor/rules/self_improve.mdc). Add new rules if: new technology/pattern used in 3+ files, common bugs could be prevented, or new best practices emerged. Update existing rules if better examples exist.
4) Mark task done in Task Master: task-master set-status --id=5 --status=done
5) Commit tasks.json: git add tasks/tasks.json && git commit -m "chore(tasks): Mark task 5 complete"
6) Commit all changes: git add . && git commit -m "feat(module): Task 5 - Implement Content Parser with HTML to Markdown Conversion [docs]"
This workflow is MANDATORY and must not be skipped. See .cursor/rules/task_completion_workflow.mdc for details.

