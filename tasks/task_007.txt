# Task ID: 7
# Title: Implement OAuth flow for CLI interaction
# Status: pending
# Dependencies: 5, 6
# Priority: medium
# Description: Create the interactive OAuth flow for CLI-based authentication
# Details:
In `src/auth/oauth_flow.py`:
1. Implement `OAuthFlow` class to orchestrate the OAuth process
2. Create a local HTTP server to listen for the OAuth callback on port 8080
3. Implement graceful handling of port conflicts:
   - Try alternative ports if 8080 is unavailable
   - Provide clear instructions if no ports are available
4. Display the authorization URL for the user to open in a browser
5. Handle the callback to receive the authorization code
6. Exchange the code for tokens using the appropriate provider
7. Save the tokens using the TokenManager
8. Provide clear success/failure messages to the user

# Test Strategy:
Write unit tests for the OAuth flow with mocked server and provider responses. Test port conflict handling. Create integration tests that simulate the full flow with mock providers.

# Subtasks:
## 1. Implement OAuthFlow class skeleton and local HTTP server on port 8080 [pending]
### Dependencies: None
### Description: Create the OAuthFlow class with basic structure and implement a simple HTTP server using Python's http.server module to listen for OAuth callbacks on localhost:8080.
### Details:
1. Create OAuthFlow class with __init__ accepting provider config (client_id, client_secret, auth_url, token_url). 2. Implement start_local_server() method using http.server.HTTPServer with a custom OAuthCallbackHandler. 3. Handler should parse query params for 'code' and 'state' parameters. 4. Use ThreadingHTTPServer for non-blocking operation. 5. Server should shut down gracefully after receiving callback. Reference: Local HTTP server pattern from Okta CLI OAuth implementation[2].

## 2. Add port conflict resolution and automatic port fallback [pending]
### Dependencies: 7.1
### Description: Implement graceful port conflict handling by trying ports 8080-8099 and providing clear user instructions when no ports are available.
### Details:
1. Create find_available_port() function that tries ports 8080-8099 sequentially using socket testing. 2. Update start_local_server() to accept/use dynamic port. 3. Store detected port in self.callback_port for redirect_uri construction. 4. If no ports available (0/20 success), raise OAuthPortError with message: 'No available ports 8080-8099. Please free a port or use manual code entry.' 5. Log successful port binding: 'Listening for OAuth callback on http://localhost:{port}'.

## 3. Implement authorization URL generation and browser opening [pending]
### Dependencies: 7.1, 7.2
### Description: Generate secure OAuth authorization URL with state parameter and automatically open user's default browser.
### Details:
1. Generate cryptographically secure state parameter using secrets.token_urlsafe(32). 2. Construct auth_url with required params: response_type='code', client_id, redirect_uri='http://localhost:{port}/callback', state, scope. 3. Store state in self._state for validation. 4. Use webbrowser.open(auth_url) to launch browser automatically. 5. Print clear instruction: 'Please authorize this application by visiting: {shortened_url}' with full URL clickable.

## 4. Implement callback handling, state validation, and token exchange [pending]
### Dependencies: 7.1, 7.2, 7.3
### Description: Handle OAuth callback, validate state parameter, extract authorization code, and exchange for access/refresh tokens.
### Details:
1. In callback handler: validate state matches self._state (reject if mismatch for CSRF protection). 2. Extract 'code' parameter and store in self.auth_code. 3. Implement exchange_tokens() method making POST to token_endpoint with grant_type='authorization_code', code, redirect_uri, client_id, client_secret. 4. Parse JSON response for access_token, refresh_token, expires_in. 5. Implement token validation (check for error responses, validate token format).

## 5. Integrate TokenManager, user messaging, and error handling [pending]
### Dependencies: 7.1, 7.2, 7.3, 7.4
### Description: Save tokens securely using TokenManager, provide clear success/failure messages, and implement comprehensive error handling.
### Details:
1. Implement run() orchestrator method calling all steps sequentially. 2. On success: token_manager.save_tokens(access_token, refresh_token, expires_at). Print 'âœ… Authentication successful! Tokens saved.' 3. Handle all failure modes: AuthError, NetworkError, TokenExchangeError with user-friendly messages. 4. Timeout after 120s if no callback received. 5. Cleanup: always shutdown server on exit. 6. Backward compatibility: support V4 token format if provider specified.

## 6. Add comprehensive testing for OAuth flow components [pending]
### Dependencies: 7.1, 7.2, 7.3, 7.4, 7.5
### Description: Create unit and integration tests covering all OAuth flow scenarios including edge cases and error conditions.
### Details:
1. Unit tests: OAuthFlow.__init__, find_available_port(), state generation/validation. 2. Mock HTTP server tests using pytest-httpserver: test callback parsing, state validation, token exchange. 3. Integration tests: full flow with mock OAuth provider. 4. Edge cases: port conflicts (8080-8082 busy), invalid state, expired code, network failures, token manager failures. 5. Test security: verify state parameter prevents CSRF. 6. Coverage target: 90%+ for oauth_flow.py.

