# Task ID: 3
# Title: Implement IMAP connection and email fetching
# Status: done
# Dependencies: 1, 2
# Priority: high
# Description: Create functionality to connect to an IMAP server and fetch emails based on configurable query
# Details:
Use Python's imaplib to establish connection to IMAP server using credentials from .env. Implement a function to execute configurable IMAP queries from config.yaml. Ensure the query excludes emails with the [AI-Processed] tag. Handle connection errors gracefully with appropriate logging. Implement email parsing to extract relevant information (subject, body, sender, etc.).

# Test Strategy:
Test IMAP connection with valid and invalid credentials. Verify query execution and email fetching. Test error handling for connection issues.

# Subtasks:
## 1. Implement IMAP connection with .env credentials [done]
### Dependencies: None
### Description: Create a function to establish secure IMAP connection using credentials loaded from .env file with proper error handling and logging.
### Details:
Use `python-dotenv` to load `IMAP_HOST`, `IMAP_USER`, `IMAP_PASSWORD` from .env. Implement `connect_imap()` function using `imaplib.IMAP4_SSL(host, port=993)`. Add `login(username, password)` call. Wrap in try-except for `imaplib.IMAP4.error` and socket errors. Use `logging` module to log connection success/failure. Ensure `logout()` and `close()` in finally block. Test with Gmail (`imap.gmail.com:993`)[1][2][4].

## 2. Load and parse configurable IMAP queries from config.yaml [done]
### Dependencies: None
### Description: Implement YAML configuration loading and query parsing logic for IMAP search criteria.
### Details:
Use `PyYAML` to load `config.yaml` containing `imap_queries: [query1, query2]` structure. Create `load_imap_queries()` function returning list of query strings. Validate queries are valid IMAP search criteria (e.g., 'UNSEEN', 'FROM "sender"'). Add logging for loaded queries. Ensure queries can be modified without code changes.

## 3. Implement IMAP search excluding [AI-Processed] tagged emails [done]
### Dependencies: 3.1, 3.2
### Description: Create search function that selects INBOX and executes configurable queries while filtering out emails with [AI-Processed] flag.
### Details:
Use `connect_imap()` from subtask 1. Implement `search_emails(imap_conn, queries)`: call `imap.select('INBOX')`, then for each query from subtask 2, execute `imap.search(None, query + ' NOT FLAGS \Seen')`. Append exclusion: search for emails NOT having `[AI-Processed]` flag using `NOT FLAGS "\\[AI-Processed\\]"`. Return list of message IDs. Log search results count[1][3][4].

## 4. Implement email fetching and parsing functionality [done]
### Dependencies: 3.1, 3.3
### Description: Fetch raw email messages and parse to extract subject, sender, body, date, and flags using email.parser.
### Details:
Create `fetch_and_parse_emails(imap_conn, msg_ids)` function. For each msg_id, call `imap.fetch(msg_id, '(RFC822)')`. Use `email.message_from_bytes(msg_data[0][1])` to parse. Extract: `msg['Subject']`, `msg['From']`, get body with `msg.get_payload(decode=True)` handling multipart/alternative. Store in dict: `{'id': msg_id, 'subject': ..., 'sender': ..., 'body': ..., 'date': msg['Date']}`. Return list of parsed emails[1][4].

## 5. Create main orchestrator with comprehensive error handling [done]
### Dependencies: 3.1, 3.2, 3.3, 3.4
### Description: Implement high-level `fetch_emails()` function integrating all components with retry logic and full error recovery.
### Details:
Create `fetch_emails()` orchestrating: load config → connect → search → fetch/parse → disconnect. Add 3-attempt retry for connection failures with exponential backoff. Implement context manager for IMAP connection. Log full workflow: 'Connected', 'Found X emails', 'Parsed Y emails'. Raise custom `IMAPFetchError` for unrecoverable failures. Include timeout handling with `imap.socket().settimeout(30)`. Test end-to-end flow[1][2][3][4].

