# Task ID: 18
# Title: Update Main Entry Point
# Status: done
# Dependencies: 10, 11, 12
# Priority: high
# Description: Refactor the main.py file to use the new architecture
# Details:
Update the main entry point to use the MasterOrchestrator and new CLI. Ensure proper initialization of all components and clean shutdown. Handle command-line arguments and environment variables according to the new multi-account architecture.

# Test Strategy:
Test the main entry point with various command-line arguments. Verify correct initialization and execution flow.

# Subtasks:
## 1. Analyze new architecture integration points for main.py [done]
### Dependencies: None
### Description: Review the new architecture to determine how main.py should initialize and interact with MasterOrchestrator and the new CLI, and identify all required inputs (CLI args, env vars, config).
### Details:
1) Inspect the MasterOrchestrator API: constructor signature, required dependencies, lifecycle methods (e.g., start(), run(), shutdown()). Document what must be provided at startup vs. what is discovered at runtime. 2) Inspect the new CLI module: how it parses arguments, how commands/subcommands are represented, and what object(s) it expects the entry point to supply (e.g., a callback, an application context, or a MasterOrchestrator instance). 3) List all configuration sources used in the new multi-account architecture (environment variables, config files, secrets, CLI flags). For each, specify key names, expected types, and which parts of the system consume them. 4) Based on existing main.py behavior, map old responsibilities (argument parsing, single-account setup, logging setup, etc.) to new equivalents in the architecture, noting anything that can now be delegated to the CLI or MasterOrchestrator. 5) Produce a short design note (can be a comment or markdown in the repo) describing the intended main() flow at a high level: parse CLI → build config from env + args → construct orchestrator → dispatch command → handle shutdown.

## 2. Implement unified configuration and environment handling for multi-account [done]
### Dependencies: 18.1
### Description: Create or refactor a configuration layer used by main.py to resolve CLI arguments and environment variables into a structured, multi-account-aware configuration object.
### Details:
1) Define a configuration model (e.g., dataclasses or plain classes) that explicitly represents multi-account state: list of accounts/profiles, per-account credentials or identifiers, global options, logging level, etc. 2) Implement functions/utilities to read and validate environment variables relevant to the new architecture (e.g., ACCOUNT_IDS, default profile, API endpoints), including sensible defaults and clear error messages when required variables are missing or invalid. 3) Implement a function that merges CLI arguments (from the new CLI parser) with environment-derived values into a single configuration object, applying precedence rules (typically: CLI > env > defaults). 4) Add validation logic for multi-account scenarios: e.g., ensure at least one account is configured, prevent conflicting flags (like mutually exclusive options), and normalize structures (e.g., split comma-separated env vars into lists). 5) Expose a simple entry function, such as build_runtime_config(parsed_args) → Config, that main.py can call to obtain a ready-to-use configuration for the MasterOrchestrator.

## 3. Refactor main.py to construct and run MasterOrchestrator [done]
### Dependencies: 18.1, 18.2
### Description: Update main.py to define a clear main() entry function that builds configuration, initializes all core components, constructs MasterOrchestrator, and delegates control flow to it.
### Details:
1) Introduce or update a main() function that becomes the single entry point for program logic, leaving only the if __name__ == "__main__": guard to call main(). 2) Within main(), create the necessary shared infrastructure components (e.g., logging setup, event loop if async, HTTP clients, repositories) that the MasterOrchestrator depends on, or delegate their creation to factory methods when they already exist. 3) Call the configuration builder from subtask 2 with the parsed CLI args to obtain a complete configuration object, and pass this into the MasterOrchestrator constructor or initialization method as required by the new architecture. 4) Invoke the appropriate orchestrator lifecycle method(s) to execute the requested operation (e.g., orchestrator.run(), orchestrator.execute_command(...)), ensuring that control flow is centralized there instead of scattered in main.py. 5) Add structured error handling around orchestrator execution (try/except) to log failures and return appropriate exit codes to the OS, keeping any complex recovery logic inside the orchestrator where possible.

## 4. Integrate new CLI parsing and command dispatch in main.py [done]
### Dependencies: 18.1, 18.2, 18.3
### Description: Wire the new CLI module into main.py so that command-line arguments are parsed according to the new interface and correctly mapped to orchestrator actions and multi-account behavior.
### Details:
1) Replace or remove any legacy argparse/CLI handling in main.py, and instead import and use the new CLI entry (e.g., a function that builds the parser or directly returns parsed arguments). 2) Ensure the CLI parser defines all commands, subcommands, and options required for the multi-account architecture (e.g., --account, --all-accounts, profile names), and that parsed_args structure matches what the configuration builder expects. 3) Adapt main() so that it first obtains parsed_args from the new CLI, then calls the config builder (subtask 2), and finally passes both the configuration and any CLI-specific command identifiers to the MasterOrchestrator. 4) Map CLI commands/subcommands to orchestrator actions in a clear, maintainable way (e.g., a dispatch table, pattern matching, or methods on the orchestrator), ensuring each command can operate on one or multiple accounts as specified. 5) Verify that help output and error messages from the CLI remain accurate after refactoring, and update any usage examples or comments that reference the old CLI behavior.

## 5. Implement clean shutdown and lifecycle management in main entry point [done]
### Dependencies: 18.3, 18.4
### Description: Ensure main.py manages application lifecycle and shutdown correctly, including resource cleanup, signal handling (if required), and consistent exit codes.
### Details:
1) Identify all resources that require explicit cleanup in the new architecture (e.g., open network connections, thread pools, async event loops, file handles) and ensure that MasterOrchestrator exposes methods or context managers to clean them up. 2) Wrap orchestrator execution in appropriate constructs (try/finally or async context managers) within main() so that cleanup is always attempted, even on errors. 3) If the architecture requires responding to termination signals (SIGINT/SIGTERM), add optional signal handlers that trigger a graceful shutdown path on the orchestrator and prevent abrupt termination where feasible. 4) Normalize exit behavior: decide on and implement a small set of exit codes (e.g., 0 for success, non-zero for different categories of failure) and ensure they are consistently returned based on orchestrator results and raised exceptions. 5) Add minimal logging around startup and shutdown events in main.py (or via orchestrator hooks) to make it easy to trace initialization and teardown in logs, and run a manual test by starting and stopping the program under typical scenarios to confirm clean shutdown.

## 6. Final stage: Validate tests, update documentation, review rules, mark done, and commit [done]
### Dependencies: 18.1, 18.2, 18.3, 18.4, 18.5
### Description: MANDATORY final stage: Run tests, update documentation, review for rule learnings, mark task done in Task Master, and commit all changes.
### Details:
1) Run full test suite: pytest -v and ensure all tests pass (new and existing). Fix any failing tests before proceeding.
2) Update/create module documentation in docs/ directory following documentation.mdc guidelines. Update docs/MAIN_DOCS.md if adding new documentation. Reference relevant PDD sections.
3) Review code for patterns that should be captured in rules (see .cursor/rules/self_improve.mdc). Add new rules if: new technology/pattern used in 3+ files, common bugs could be prevented, or new best practices emerged. Update existing rules if better examples exist.
4) Mark task done in Task Master: task-master set-status --id=18 --status=done
5) Commit tasks.json: git add tasks/tasks.json && git commit -m "chore(tasks): Mark task 18 complete"
6) Commit all changes: git add . && git commit -m "feat(module): Task 18 - Update Main Entry Point [docs]"
This workflow is MANDATORY and must not be skipped. See .cursor/rules/task_completion_workflow.mdc for details.

