{
  "tasks": [
    {
      "id": 1,
      "title": "Set up project structure and dependencies",
      "description": "Create the necessary directory structure and add required dependencies for OAuth integration",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "1. Create `src/auth/` directory with files: `__init__.py`, `interfaces.py`, `oauth_flow.py`, `token_manager.py`, `strategies.py`\n2. Create `src/auth/providers/` directory with files: `__init__.py`, `google.py`, `microsoft.py`\n3. Create `credentials/` directory for token storage\n4. Add `credentials/` to `.gitignore`\n5. Add dependencies to `requirements.txt`: `google-auth-oauthlib`, `msal`\n6. Set appropriate file permissions for the credentials directory (chmod 700)",
      "testStrategy": "Verify all directories and files are created with correct structure. Confirm dependencies are installed correctly using `pip install -r requirements.txt`. Check that credentials directory has proper permissions."
    },
    {
      "id": 2,
      "title": "Define authentication interfaces and base classes",
      "description": "Implement the authenticator protocol and base classes for the strategy pattern",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "In `src/auth/interfaces.py`:\n1. Define `AuthenticatorProtocol` with `authenticate(imap_connection)` method\n2. Create abstract base classes for providers: `OAuthProvider` with methods for generating auth URLs, handling callbacks, and token exchange\n3. Define common interfaces and types for token management\n4. Create utility functions for SASL string generation for XOAUTH2\n\nEnsure all interfaces use proper type hints and docstrings for clarity.",
      "testStrategy": "Write unit tests to verify interface definitions. Use static type checking with mypy to ensure protocol adherence.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define AuthenticatorProtocol and core type aliases",
          "description": "Create the main protocol interface and essential type definitions for token management with proper type hints and docstrings.",
          "status": "done",
          "dependencies": [],
          "details": "In `src/auth/interfaces.py`:\n- Define `AuthenticatorProtocol` (Protocol) with `authenticate(imap_connection: IMAP4_SSL) -> bool` method and comprehensive docstring explaining IMAP SASL XOAUTH2 usage.\n- Add `TokenInfo = TypedDict('TokenInfo', {'access_token': str, 'expires_at': Optional[datetime], 'refresh_token': Optional[str]})` for OAuth token structure.\n- Define `OAuthConfig = TypedDict('OAuthConfig', {'client_id': str, 'client_secret': str, 'redirect_uri': str, 'scopes': list[str], 'auth_url': str, 'token_url': str})`.\n- Include validation for required OAuth 2.0 security parameters per RFC 6749."
        },
        {
          "id": 2,
          "title": "Implement OAuthProvider abstract base class",
          "description": "Create the base ABC for OAuth providers implementing strategy pattern with core OAuth 2.0 Authorization Code Flow methods.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Define `OAuthProvider(ABC)` with:\n- `@abstractmethod def get_auth_url(state: str) -> str`: Generates authorization URL with PKCE challenge if supported.\n- `@abstractmethod def handle_callback(code: str, state: str) -> TokenInfo`: Exchanges code for tokens.\n- `@abstractmethod def refresh_token(token_info: TokenInfo) -> TokenInfo`: Handles token refresh.\n- `validate_token(token_info: TokenInfo) -> bool`: Checks expiration with 5min buffer.\n- Include docstrings referencing OAuth 2.0 RFCs and security best practices (state validation, PKCE)."
        },
        {
          "id": 3,
          "title": "Add token management utilities and error handling",
          "description": "Implement common token utilities and comprehensive error handling interfaces for robust OAuth implementation.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "details": "Add to `interfaces.py`:\n- `TokenError`, `OAuthError`, `AuthExpiredError` custom exceptions with proper inheritance.\n- `is_token_valid(token_info: TokenInfo, clock_skew: int = 300) -> bool`: Expiration validation utility.\n- `parse_token_response(response: dict) -> TokenInfo`: Safe JSON parsing with validation.\n- `generate_state() -> str` and `generate_pkce_challenge() -> tuple[str, str]`: Security utilities.\n- Define `ProviderFactory = Callable[[OAuthConfig], OAuthProvider]` protocol for dependency injection."
        },
        {
          "id": 4,
          "title": "Implement XOAUTH2 SASL utilities",
          "description": "Create SASL string generation functions specifically for IMAP XOAUTH2 authentication per RFC 7628.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Add SASL utilities:\n- `generate_xoauth2_sasl(user: str, access_token: str) -> bytes`: Implements base64('user=' + user + '^Aauth=Bearer ' + token + '^A^A').\n- `validate_sasl_components(user: str, token: str) -> None`: Input validation.\n- Include unit test functions: `test_sasl_base64_encoding()`, `test_sasl_format_rfc7628()`.\n- Docstrings must reference RFC 7628 XOAUTH2 specification and include example SASL strings."
        },
        {
          "id": 5,
          "title": "Add comprehensive docstrings and type validation tests",
          "description": "Complete interfaces with full documentation, backward compatibility checks, and interface compliance tests.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Finalize with:\n- Google-style docstrings for all protocols/ABCs with Args, Returns, Raises sections.\n- V4 compatibility: `is_v4_compatible(provider: OAuthProvider) -> bool` utility.\n- Test subtasks: `test_protocol_compliance()`, `test_type_hints_mypy()`, `test_docstring_coverage()`, `test_sasl_roundtrip()`.\n- Add `__all__ = [...]` export list and `version = '1.0.0'` for backward compatibility tracking."
        }
      ]
    },
    {
      "id": 3,
      "title": "Update configuration schema for OAuth support",
      "description": "Modify the configuration schema to include OAuth authentication options",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "1. Update `src/config_schema.py` to include the new `auth` block in account configuration\n2. Implement validation for the auth block using Pydantic discriminated unions:\n   - If `method=\"oauth\"`, then `provider` is mandatory and `password_env` is ignored\n   - If `method=\"password\"`, `password_env` is mandatory\n3. Set default value for `method` as `\"password\"` for backward compatibility\n4. Add validation for `provider` field to accept only `\"google\"` or `\"microsoft\"`\n5. Ensure the schema maintains backward compatibility with existing configurations",
      "testStrategy": "Write unit tests with various configuration scenarios: missing auth block, oauth method without provider, password method without password_env, etc. Verify backward compatibility with existing V4 configurations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Add OAuth auth block to base config schema",
          "description": "Update `src/config_schema.py` to include the new `auth` block with discriminated union structure and default values for backward compatibility.",
          "status": "done",
          "dependencies": [],
          "details": "Define Pydantic BaseModel for `AuthConfig` using discriminated unions with `method: Literal['password', 'oauth'] = 'password'`. Add `provider: Optional[Literal['google', 'microsoft']] = None` and `password_env: Optional[str] = None`. Nest within existing account configuration structure. Ensure existing configs without `auth` block default to `method='password'`."
        },
        {
          "id": 2,
          "title": "Implement conditional validation logic for auth methods",
          "description": "Add Pydantic validators to enforce conditional field requirements based on `method` value.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Use `@validator('provider', 'password_env', pre=True)` or `@root_validator` to implement logic: when `method == 'oauth'`, require `provider` and ignore `password_env`; when `method == 'password'`, require `password_env`. Raise `ValueError` with clear messages for security best practices. Test edge cases like missing fields."
        },
        {
          "id": 3,
          "title": "Add provider enum validation and OAuth 2.0 fields",
          "description": "Restrict `provider` to Google/Microsoft and add OAuth 2.0 specific configuration fields.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "Create `OAuthProviderConfig` model with `client_id`, `client_secret_env`, `redirect_uri`, and `scopes: List[str] = []` fields following OAuth 2.0 standards from Google/Microsoft docs. Embed within `auth` block when `provider` is set. Include `access_type: str = 'offline'` and `include_granted_scopes: bool = True` for best practices."
        },
        {
          "id": 4,
          "title": "Ensure V4 backward compatibility and migration handling",
          "description": "Verify existing V4 configurations parse correctly and add migration warnings.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Test parsing of V4 configs missing `auth` block (should default to password). Add `deprecated` field warnings for configs without explicit `method`. Implement custom `Config` class with `extra='ignore'` or `allow_population_by_field_name=True`. Log deprecation warnings for `password`-only configs."
        },
        {
          "id": 5,
          "title": "Add comprehensive unit tests for auth schema validation",
          "description": "Create test suite covering all validation paths, edge cases, and backward compatibility.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Write pytest cases for: 1) Valid OAuth configs (google/microsoft), 2) Valid password configs, 3) Invalid provider values, 4) Missing required fields per method, 5) V4 backward compatibility, 6) Extra unknown fields ignored, 7) Default `method='password'` behavior. Target 100% validation path coverage."
        }
      ]
    },
    {
      "id": 4,
      "title": "Implement token management system",
      "description": "Create a token manager to handle storage, loading, and refreshing of OAuth tokens",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "In `src/auth/token_manager.py`:\n1. Implement `TokenManager` class with methods:\n   - `save_tokens(account_name, tokens)`: Store tokens in JSON format in credentials directory\n   - `load_tokens(account_name)`: Load tokens from file\n   - `refresh_token(account_name, provider)`: Refresh access token using refresh token\n   - `get_valid_token(account_name, provider)`: Get a valid access token, refreshing if needed\n2. Implement security measures:\n   - Set file permissions to 0600 for token files\n   - Handle file I/O exceptions gracefully\n3. Add token expiry checking with a 5-minute buffer before expiration\n4. Implement token refresh logic that works synchronously",
      "testStrategy": "Write unit tests for token saving, loading, and refreshing. Mock file I/O and token refresh responses. Test expiry checking with various timestamps. Verify file permissions are set correctly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create TokenManager class skeleton with save_tokens and load_tokens methods",
          "description": "Implement the basic TokenManager class structure with token storage and retrieval using JSON files in credentials directory.",
          "status": "done",
          "dependencies": [],
          "details": "1. Create `src/auth/token_manager.py` with `TokenManager` class. 2. Implement `save_tokens(account_name, tokens)`: Create credentials directory if missing (`os.makedirs`), save tokens as JSON with filename `{account_name}.json`, set permissions to 0600 using `os.chmod(0o600)`. 3. Implement `load_tokens(account_name)`: Return tokens dict from JSON file or None if missing. 4. Add file path helper method `_get_token_path(account_name)`. 5. Handle FileNotFoundError and PermissionError with logging."
        },
        {
          "id": 2,
          "title": "Implement token expiry checking logic",
          "description": "Add token validation with 5-minute expiry buffer to determine if tokens need refreshing.",
          "status": "done",
          "dependencies": [
            1
          ],
          "details": "1. Add `_is_token_expired(tokens)` private method that parses `expires_at` or calculates from `expires_in` + current time. 2. Apply **5-minute buffer**: return True if expiry time <= `time.time() + 300`. 3. Handle missing/invalid expiry fields by treating as expired. 4. Add logging for expiry status. 5. Test edge cases: valid token, expired token, missing expiry, malformed expiry."
        },
        {
          "id": 3,
          "title": "Implement synchronous refresh_token method",
          "description": "Create OAuth 2.0 refresh logic that calls provider token endpoint using refresh_token.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement `refresh_token(account_name, provider)`: Load existing tokens, construct refresh request per OAuth 2.0 spec (`grant_type=refresh_token`, `refresh_token`, provider-specific client_id/secret). 2. Use `requests.post()` to provider's token endpoint. 3. Parse response for new `access_token`, `refresh_token`, `expires_in`. 4. Calculate `expires_at = time.time() + expires_in`. 5. Save refreshed tokens via `save_tokens`. 6. Raise custom `TokenRefreshError` on 4xx/5xx responses with provider error details."
        },
        {
          "id": 4,
          "title": "Implement get_valid_token with automatic refresh",
          "description": "Create main public method that returns valid access token, automatically refreshing when needed.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Implement `get_valid_token(account_name, provider)`: Load tokens, check expiry with buffer. 2. If expired/missing → call `refresh_token(account_name, provider)`. 3. Return `tokens['access_token']`. 4. Add retry logic (max 1 retry) for race conditions. 5. Cache valid tokens briefly using instance variable with TTL. 6. Return None if refresh fails after retry."
        },
        {
          "id": 5,
          "title": "Add comprehensive security and error handling",
          "description": "Implement production-grade security measures, exception handling, and logging.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Wrap all file I/O in try/except for OSError, PermissionError, json.JSONDecodeError. 2. Add request timeout (30s) and SSL verification to refresh requests. 3. Validate tokens dict structure before save/load. 4. Implement atomic file writes using temp files + `os.rename()`. 5. Add structured logging with account_name, provider, operation result. 6. Ensure backward compatibility: handle V4 token formats gracefully."
        },
        {
          "id": 6,
          "title": "Write unit tests for all TokenManager functionality",
          "description": "Create comprehensive test suite covering all methods, edge cases, and error conditions.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "1. Create `tests/test_token_manager.py` using pytest. 2. Test save/load roundtrip with valid/invalid tokens. 3. Test expiry logic: future/past expiry, buffer edge cases. 4. Mock `requests.post()` for refresh_token success/failure scenarios. 5. Test get_valid_token: valid→no refresh, expired→refresh, refresh fail→None. 6. Test file permissions (0600), error handling, race conditions. 7. Test coverage >90%."
        }
      ]
    },
    {
      "id": 5,
      "title": "Implement Google OAuth provider",
      "description": "Create the Google-specific OAuth implementation",
      "status": "pending",
      "dependencies": [
        2,
        4
      ],
      "priority": "medium",
      "details": "In `src/auth/providers/google.py`:\n1. Implement `GoogleOAuthProvider` class that extends the base provider interface\n2. Use `google-auth-oauthlib` library for OAuth flow\n3. Implement methods for:\n   - Generating authorization URL with correct scope: `https://mail.google.com/`\n   - Handling authorization code callback\n   - Exchanging code for tokens\n   - Refreshing tokens\n4. Read client ID and secret from environment variables: `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`\n5. Handle error cases gracefully with informative messages",
      "testStrategy": "Write unit tests with mocked Google API responses. Test authorization URL generation, token exchange, and refresh flows. Verify correct scopes are requested. Test error handling with various API error responses.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Google OAuth credentials and environment configuration",
          "description": "Create and configure Google OAuth 2.0 credentials in Google Cloud Console, then implement environment variable loading for client ID and secret.",
          "status": "pending",
          "dependencies": [],
          "details": "1. Create OAuth 2.0 client ID in Google Cloud Console by setting up the OAuth consent screen with app name and support email[1][2]\n2. Configure authorized redirect URI to match your application's callback endpoint (e.g., `/authorize` or `/oauth2callback`)[1][4]\n3. Download client credentials and extract client ID and client secret\n4. Create `.env` file with `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` environment variables\n5. Implement environment variable loading in `src/auth/providers/google.py` using `os.getenv()` with validation to ensure both variables are present\n6. Add error handling to raise informative exceptions if credentials are missing at initialization time"
        },
        {
          "id": 2,
          "title": "Create GoogleOAuthProvider class structure with base interface implementation",
          "description": "Define the GoogleOAuthProvider class that extends the base OAuth provider interface with required method signatures.",
          "status": "pending",
          "dependencies": [],
          "details": "1. Create `GoogleOAuthProvider` class in `src/auth/providers/google.py` that inherits from the base provider interface\n2. Define class attributes for storing client ID, client secret, and redirect URI\n3. Implement `__init__` method that accepts configuration parameters and initializes the provider with environment variables from subtask 1\n4. Define method signatures for: `get_authorization_url()`, `handle_callback()`, `exchange_code_for_tokens()`, and `refresh_access_token()`\n5. Add a private method `_validate_configuration()` to verify all required credentials are available\n6. Include docstrings for all methods describing parameters, return values, and potential exceptions"
        },
        {
          "id": 3,
          "title": "Implement authorization URL generation with correct scopes",
          "description": "Implement the method to generate Google OAuth authorization URLs with proper scope configuration for Gmail access.",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Use `google_auth_oauthlib.flow.Flow.from_client_secrets_file()` or construct Flow manually with client credentials[3]\n2. Configure scopes to include `https://mail.google.com/` as specified, plus `openid`, `email`, and `profile` for user identification[1][3]\n3. Set the redirect URI to match the value configured in Google Cloud Console and environment\n4. Implement `get_authorization_url()` method that returns the authorization URL string\n5. Store the Flow object as an instance variable for use in subsequent token exchange steps\n6. Add error handling for invalid configuration or Flow initialization failures with descriptive error messages"
        },
        {
          "id": 4,
          "title": "Implement authorization code callback handling and token exchange",
          "description": "Implement the callback handler that receives authorization codes and exchanges them for access and refresh tokens.",
          "status": "pending",
          "dependencies": [
            2,
            3
          ],
          "details": "1. Implement `handle_callback()` method that accepts the authorization code from the redirect URI[4]\n2. Validate the authorization code format and presence\n3. Use `flow.fetch_token()` method to exchange the authorization code for tokens[4]\n4. Extract and store access token, refresh token, and token expiration time from the response\n5. Implement `exchange_code_for_tokens()` method that returns a structured token object containing: access_token, refresh_token, expires_in, and token_type\n6. Add comprehensive error handling for: invalid codes, network failures, and Google API errors with user-friendly error messages"
        },
        {
          "id": 5,
          "title": "Implement token refresh mechanism with expiration handling",
          "description": "Implement the token refresh functionality to maintain valid access tokens and handle token expiration scenarios.",
          "status": "pending",
          "dependencies": [
            2,
            4
          ],
          "details": "1. Implement `refresh_access_token()` method that accepts a refresh token as input\n2. Use the stored Flow object or create a new credentials object from the refresh token\n3. Call the appropriate Google Auth library method to refresh the access token\n4. Return updated token information including new access token, expiration time, and any updated refresh token\n5. Implement token expiration checking logic that determines if a token needs refresh (e.g., if expiration is within 5 minutes)\n6. Add error handling for: invalid refresh tokens, revoked credentials, and network failures with clear error messages indicating whether the user needs to re-authenticate"
        },
        {
          "id": 6,
          "title": "Add comprehensive error handling, logging, and unit tests",
          "description": "Implement error handling throughout the provider, add logging for debugging, and create unit tests for all major components.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "1. Add try-catch blocks around all Google API calls with specific exception handling for: `google.auth.exceptions.GoogleAuthError`, network errors, and invalid credentials\n2. Implement logging using Python's `logging` module to track: authorization URL generation, token exchanges, refreshes, and errors\n3. Create custom exception classes for Google OAuth-specific errors (e.g., `GoogleOAuthError`, `TokenRefreshError`)\n4. Write unit tests covering: successful authorization URL generation, valid token exchange, token refresh with valid refresh token, token refresh with expired/invalid token, missing environment variables, and network failure scenarios\n5. Add integration tests that verify the complete OAuth flow from authorization to token refresh\n6. Document error codes and troubleshooting steps in code comments and docstrings for maintainability"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Microsoft OAuth provider",
      "description": "Create the Microsoft-specific OAuth implementation",
      "status": "pending",
      "dependencies": [
        2,
        4
      ],
      "priority": "medium",
      "details": "In `src/auth/providers/microsoft.py`:\n1. Implement `MicrosoftOAuthProvider` class that extends the base provider interface\n2. Use `msal` library for OAuth flow\n3. Implement methods for:\n   - Generating authorization URL with correct scopes: `https://outlook.office.com/IMAP.AccessAsUser.All`, `https://outlook.office.com/User.Read`, `offline_access`\n   - Handling authorization code callback\n   - Exchanging code for tokens\n   - Refreshing tokens\n4. Read client ID and secret from environment variables: `MS_CLIENT_ID` and `MS_CLIENT_SECRET`\n5. Handle error cases gracefully with informative messages\n6. Ensure `offline_access` scope is included to enable refresh tokens",
      "testStrategy": "Write unit tests with mocked Microsoft API responses. Test authorization URL generation, token exchange, and refresh flows. Verify correct scopes are requested. Test error handling with various API error responses.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create MicrosoftOAuthProvider class skeleton and configure MSAL app",
          "description": "Implement the base class structure, load environment variables, and initialize MSAL PublicClientApplication with Microsoft-specific endpoints and scopes.",
          "status": "pending",
          "dependencies": [],
          "details": "1. Create `MicrosoftOAuthProvider` class inheriting from base OAuth provider interface in `src/auth/providers/microsoft.py`. 2. Load `MS_CLIENT_ID` and `MS_CLIENT_SECRET` from environment variables using `os.getenv()`. 3. Initialize `msal.PublicClientApplication` with authority `https://login.microsoftonline.com/common`, client_id, and client_credential. 4. Define required scopes: `['https://outlook.office.com/IMAP.AccessAsUser.All', 'https://outlook.office.com/User.Read', 'offline_access']`. 5. Add basic error handling for missing environment variables with descriptive messages."
        },
        {
          "id": 2,
          "title": "Implement authorization URL generation",
          "description": "Create method to generate Microsoft authorization URL using MSAL's `initiate_auth_code_flow()` with correct scopes and state parameter.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "1. Implement `get_authorization_url()` method that calls `msal_app.initiate_auth_code_flow(scopes=scopes, redirect_uri=self.redirect_uri)`. 2. Generate cryptographically secure state using `secrets.token_urlsafe(32)` or `uuid.uuid4()`. 3. Store flow state in class instance or session for validation. 4. Return auth URL, state, and flow data. 5. Ensure `offline_access` scope is included for refresh token support. 6. Add validation for required scopes presence."
        },
        {
          "id": 3,
          "title": "Implement authorization callback handling and token exchange",
          "description": "Create callback handler to process authorization code, validate state, and exchange code for access/refresh tokens using MSAL.",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement `handle_callback()` method accepting code and state parameters. 2. Validate state matches stored value from authorization step. 3. Call `msal_app.acquire_token_by_auth_code_flow(flow, {'code': code, 'state': state})`. 4. Extract `access_token`, `refresh_token`, `id_token`, and `expires_in` from result. 5. Handle MSAL errors (`MsalError`) with specific error messages for invalid code, expired code, etc. 6. Return standardized token response matching base provider interface."
        },
        {
          "id": 4,
          "title": "Implement token refresh functionality",
          "description": "Add refresh token method using MSAL's `acquire_token_silent()` and `acquire_token_by_refresh_token()` flows.",
          "status": "pending",
          "dependencies": [
            1,
            3
          ],
          "details": "1. Implement `refresh_tokens()` method accepting current refresh_token. 2. First attempt silent refresh with `acquire_token_silent(scopes=scopes, account=None)`. 3. Fallback to explicit refresh: `acquire_token_by_refresh_token(refresh_token, scopes=scopes)`. 4. Handle token expiration gracefully by checking `expires_on`. 5. Return new access_token, refresh_token, and expiry info. 6. Implement retry logic (max 2 attempts) for transient auth failures."
        },
        {
          "id": 5,
          "title": "Add comprehensive error handling and logging",
          "description": "Implement robust error handling for all OAuth flows with specific error messages, logging, and security best practices.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Create custom `MicrosoftOAuthError` exception subclass. 2. Add structured logging using `logging` module for all major operations (auth URL generation, callback, refresh). 3. Handle specific MSAL error codes: `invalid_grant`, `interaction_required`, `consent_required`. 4. Sanitize error responses (never expose client_secret or tokens in logs). 5. Implement request timeout (30s) and connection error handling. 6. Add input validation for code, state, and token parameters."
        },
        {
          "id": 6,
          "title": "Write unit tests for all Microsoft OAuth components",
          "description": "Create comprehensive test suite covering authorization flow, token exchange, refresh, and error scenarios using pytest and pytest-mock.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "1. Create `tests/auth/providers/test_microsoft.py`. 2. Mock `msal.PublicClientApplication` using `pytest-mock`. 3. Test successful auth URL generation with correct scopes. 4. Test callback handling with valid/invalid codes and state mismatch. 5. Test token refresh with expired and valid refresh tokens. 6. Test error scenarios: missing env vars, network failures, invalid scopes. 7. Verify `offline_access` scope presence and security headers. 8. Achieve 90%+ code coverage."
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement OAuth flow for CLI interaction",
      "description": "Create the interactive OAuth flow for CLI-based authentication",
      "status": "pending",
      "dependencies": [
        5,
        6
      ],
      "priority": "medium",
      "details": "In `src/auth/oauth_flow.py`:\n1. Implement `OAuthFlow` class to orchestrate the OAuth process\n2. Create a local HTTP server to listen for the OAuth callback on port 8080\n3. Implement graceful handling of port conflicts:\n   - Try alternative ports if 8080 is unavailable\n   - Provide clear instructions if no ports are available\n4. Display the authorization URL for the user to open in a browser\n5. Handle the callback to receive the authorization code\n6. Exchange the code for tokens using the appropriate provider\n7. Save the tokens using the TokenManager\n8. Provide clear success/failure messages to the user",
      "testStrategy": "Write unit tests for the OAuth flow with mocked server and provider responses. Test port conflict handling. Create integration tests that simulate the full flow with mock providers.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement OAuthFlow class skeleton and local HTTP server on port 8080",
          "description": "Create the OAuthFlow class with basic structure and implement a simple HTTP server using Python's http.server module to listen for OAuth callbacks on localhost:8080.",
          "status": "pending",
          "dependencies": [],
          "details": "1. Create OAuthFlow class with __init__ accepting provider config (client_id, client_secret, auth_url, token_url). 2. Implement start_local_server() method using http.server.HTTPServer with a custom OAuthCallbackHandler. 3. Handler should parse query params for 'code' and 'state' parameters. 4. Use ThreadingHTTPServer for non-blocking operation. 5. Server should shut down gracefully after receiving callback. Reference: Local HTTP server pattern from Okta CLI OAuth implementation[2]."
        },
        {
          "id": 2,
          "title": "Add port conflict resolution and automatic port fallback",
          "description": "Implement graceful port conflict handling by trying ports 8080-8099 and providing clear user instructions when no ports are available.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "1. Create find_available_port() function that tries ports 8080-8099 sequentially using socket testing. 2. Update start_local_server() to accept/use dynamic port. 3. Store detected port in self.callback_port for redirect_uri construction. 4. If no ports available (0/20 success), raise OAuthPortError with message: 'No available ports 8080-8099. Please free a port or use manual code entry.' 5. Log successful port binding: 'Listening for OAuth callback on http://localhost:{port}'."
        },
        {
          "id": 3,
          "title": "Implement authorization URL generation and browser opening",
          "description": "Generate secure OAuth authorization URL with state parameter and automatically open user's default browser.",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Generate cryptographically secure state parameter using secrets.token_urlsafe(32). 2. Construct auth_url with required params: response_type='code', client_id, redirect_uri='http://localhost:{port}/callback', state, scope. 3. Store state in self._state for validation. 4. Use webbrowser.open(auth_url) to launch browser automatically. 5. Print clear instruction: 'Please authorize this application by visiting: {shortened_url}' with full URL clickable."
        },
        {
          "id": 4,
          "title": "Implement callback handling, state validation, and token exchange",
          "description": "Handle OAuth callback, validate state parameter, extract authorization code, and exchange for access/refresh tokens.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. In callback handler: validate state matches self._state (reject if mismatch for CSRF protection). 2. Extract 'code' parameter and store in self.auth_code. 3. Implement exchange_tokens() method making POST to token_endpoint with grant_type='authorization_code', code, redirect_uri, client_id, client_secret. 4. Parse JSON response for access_token, refresh_token, expires_in. 5. Implement token validation (check for error responses, validate token format)."
        },
        {
          "id": 5,
          "title": "Integrate TokenManager, user messaging, and error handling",
          "description": "Save tokens securely using TokenManager, provide clear success/failure messages, and implement comprehensive error handling.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Implement run() orchestrator method calling all steps sequentially. 2. On success: token_manager.save_tokens(access_token, refresh_token, expires_at). Print '✅ Authentication successful! Tokens saved.' 3. Handle all failure modes: AuthError, NetworkError, TokenExchangeError with user-friendly messages. 4. Timeout after 120s if no callback received. 5. Cleanup: always shutdown server on exit. 6. Backward compatibility: support V4 token format if provider specified."
        },
        {
          "id": 6,
          "title": "Add comprehensive testing for OAuth flow components",
          "description": "Create unit and integration tests covering all OAuth flow scenarios including edge cases and error conditions.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "1. Unit tests: OAuthFlow.__init__, find_available_port(), state generation/validation. 2. Mock HTTP server tests using pytest-httpserver: test callback parsing, state validation, token exchange. 3. Integration tests: full flow with mock OAuth provider. 4. Edge cases: port conflicts (8080-8082 busy), invalid state, expired code, network failures, token manager failures. 5. Test security: verify state parameter prevents CSRF. 6. Coverage target: 90%+ for oauth_flow.py."
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement authentication strategies",
      "description": "Create concrete authenticator classes for password and OAuth methods",
      "status": "pending",
      "dependencies": [
        2,
        4,
        5,
        6
      ],
      "priority": "high",
      "details": "In `src/auth/strategies.py`:\n1. Implement `PasswordAuthenticator` class:\n   - Initialize with email and password (from environment variable)\n   - Implement `authenticate(imap_conn)` method using `imap_conn.login(email, password)`\n2. Implement `OAuthAuthenticator` class:\n   - Initialize with email, account name, provider name, and TokenManager\n   - Implement `authenticate(imap_conn)` method:\n     - Get valid access token from TokenManager (refreshing if needed)\n     - Generate SASL string: `user={email}\\x01auth=Bearer {token}\\x01\\x01`\n     - Call `imap_conn.authenticate('XOAUTH2', sasl_string)`\n3. Implement error handling for authentication failures",
      "testStrategy": "Write unit tests for both authenticator classes with mocked IMAP connections. Test successful authentication and various failure scenarios. Verify token refresh is triggered when token is near expiration.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement PasswordAuthenticator class",
          "description": "Create the PasswordAuthenticator class with initialization from environment variables and basic login authentication method.",
          "status": "pending",
          "dependencies": [],
          "details": "In `src/auth/strategies.py`, implement `PasswordAuthenticator` class that: 1) Initializes with `email` and `password` loaded securely from environment variables using `os.getenv()`; 2) Implements `authenticate(imap_conn)` method calling `imap_conn.login(email, password)`; 3) Use `IMAP4_SSL` with `ssl.create_default_context()` for secure connections per Python imaplib best practices[1][3]."
        },
        {
          "id": 2,
          "title": "Implement OAuthAuthenticator class structure",
          "description": "Create OAuthAuthenticator class with proper initialization and token management integration.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Implement `OAuthAuthenticator` class that: 1) Initializes with `email`, `account_name`, `provider_name`, and `TokenManager` instance; 2) Stores these parameters as instance variables; 3) Prepares for SASL XOAUTH2 authentication following OAuth 2.0 IMAP standards[6]. Ensure TokenManager dependency is properly imported and type-hinted."
        },
        {
          "id": 3,
          "title": "Implement OAuth SASL authentication logic",
          "description": "Add the core OAuth authentication method with proper SASL XOAUTH2 string construction.",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "In `OAuthAuthenticator.authenticate(imap_conn)`: 1) Call `TokenManager.get_valid_access_token()` (refreshing if needed); 2) Construct SASL string exactly as `user={email}\\x01auth=Bearer {token}\\x01\\x01`; 3) Call `imap_conn.authenticate('XOAUTH2', sasl_string.encode('utf-8'))` per IMAP XOAUTH2 specification[3][6]. Handle base64 encoding if required by specific providers."
        },
        {
          "id": 4,
          "title": "Add comprehensive error handling",
          "description": "Implement robust error handling and exception mapping for both authentication strategies.",
          "status": "pending",
          "dependencies": [
            1,
            3
          ],
          "details": "Add try-catch blocks around authentication calls: 1) Catch `imaplib.IMAP4.error` and map to custom `AuthenticationError` with specific messages ('AUTHENTICATIONFAILED', token refresh failures, etc.); 2) Log detailed errors using structured logging; 3) Provide backward compatibility with V4 error formats; 4) Ensure password errors don't leak credentials in error messages[1]."
        },
        {
          "id": 5,
          "title": "Create unit tests for both authenticators",
          "description": "Write comprehensive tests covering success/failure scenarios for both authentication strategies.",
          "status": "pending",
          "dependencies": [
            4
          ],
          "details": "Create tests in `tests/test_auth_strategies.py`: 1) Mock `imaplib.IMAP4_SSL` and `TokenManager` using `unittest.mock`; 2) Test `PasswordAuthenticator` success/failure paths; 3) Test `OAuthAuthenticator` with valid/expired tokens and SASL string construction; 4) Verify error handling and exception types; 5) Test security practices (no credential leaks in errors, proper SSL context)."
        }
      ]
    },
    {
      "id": 9,
      "title": "Refactor IMAP client to use authenticator strategy",
      "description": "Modify the IMAP client to use the authenticator strategy pattern",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "high",
      "details": "In `src/imap_client.py`:\n1. Modify `IMAPClient.__init__` to accept an `authenticator` parameter\n2. Remove direct credential handling from the client\n3. Update `connect()` method to use `self.authenticator.authenticate(self.server)` instead of direct login\n4. Ensure backward compatibility by handling cases where authenticator is not provided\n5. Add appropriate error handling for authentication failures\n6. Update docstrings and type hints",
      "testStrategy": "Write unit tests for the refactored IMAP client with mocked authenticators. Test both password and OAuth authentication methods. Verify backward compatibility with existing code. Test error handling for authentication failures.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and implement authenticator strategy interface",
          "description": "Create an abstract base class or protocol that defines the authenticator strategy pattern. This interface will establish the contract that all authentication mechanisms must follow, enabling pluggable authentication implementations.",
          "status": "pending",
          "dependencies": [],
          "details": "Create an `Authenticator` abstract base class in a new module `src/authenticators/base.py` with an abstract method `authenticate(server)` that returns authentication status. Define the method signature to accept an IMAP server connection object and raise appropriate exceptions (e.g., `AuthenticationError`) on failure. Include type hints for all parameters and return values. Document the interface with docstrings explaining the expected behavior, error conditions, and how implementations should handle OAuth 2.0 tokens versus traditional credentials. Consider adding optional methods like `refresh_token()` for token-based authentication. This foundation enables the client refactoring in subsequent subtasks."
        },
        {
          "id": 2,
          "title": "Implement concrete authenticator strategies (PLAIN, OAuth2, NTLM)",
          "description": "Create concrete implementations of the authenticator interface for different authentication mechanisms, including PLAIN (basic username/password), OAuth 2.0, and NTLM, following RFC 3501 and modern security standards.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Implement three authenticator classes in `src/authenticators/`: (1) `PlainAuthenticator` for traditional username/password authentication using SASL PLAIN mechanism as documented in RFC 4616; (2) `OAuth2Authenticator` supporting token-based authentication with token refresh capabilities, aligned with Microsoft's Modern Authentication enforcement (effective April 30, 2026 per search results); (3) `NTLMAuthenticator` for NTLM-based authentication. Each implementation should handle the challenge-response flow appropriately. Include proper error handling with descriptive messages. Add logging for authentication attempts and failures. Implement token caching and refresh logic for OAuth2. Include docstrings with usage examples and security considerations."
        },
        {
          "id": 3,
          "title": "Refactor IMAPClient.__init__ to accept authenticator parameter",
          "description": "Modify the IMAPClient constructor to accept an optional authenticator parameter while maintaining backward compatibility with existing code that passes credentials directly.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Update `src/imap_client.py` IMAPClient.__init__ signature to include an optional `authenticator: Optional[Authenticator] = None` parameter. Implement backward compatibility logic: if `authenticator` is None but username/password are provided, automatically instantiate a `PlainAuthenticator` internally. Store the authenticator as `self.authenticator`. Add comprehensive type hints using `Optional`, `Union`, and `Authenticator` types. Update the docstring to document both the new authenticator parameter and the legacy credential parameters, clearly marking the legacy approach as deprecated. Include a deprecation warning when credentials are passed directly. Add validation to ensure either an authenticator or credentials are provided, raising `ValueError` if neither is supplied."
        },
        {
          "id": 4,
          "title": "Update connect() and authentication flow to use authenticator strategy",
          "description": "Refactor the connect() method to delegate authentication to the authenticator strategy instead of handling credentials directly, implementing proper error handling and security practices.",
          "status": "pending",
          "dependencies": [
            2,
            3
          ],
          "details": "Modify the `connect()` method in `src/imap_client.py` to call `self.authenticator.authenticate(self.server)` instead of direct `login()` calls. Implement comprehensive error handling with try-except blocks that catch `AuthenticationError` and other exceptions, providing clear error messages distinguishing between authentication failures, network issues, and server errors. Add logging at appropriate levels (debug for successful auth, error for failures). Implement retry logic with exponential backoff for transient failures. Ensure SSL/TLS encryption is enforced on port 993 per security best practices. Add context managers for secure connection handling. Update docstrings to reflect the new authentication flow. Include security considerations in documentation regarding token storage and credential handling."
        },
        {
          "id": 5,
          "title": "Add comprehensive testing and validation for authenticator strategies",
          "description": "Create unit tests and integration tests covering all authenticator implementations, backward compatibility scenarios, error handling, and security edge cases.",
          "status": "pending",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Create `tests/test_authenticators.py` with unit tests for each authenticator class covering: successful authentication, invalid credentials, token refresh (OAuth2), challenge-response handling (NTLM), and error conditions. Create `tests/test_imap_client_auth.py` with integration tests verifying: authenticator parameter acceptance, backward compatibility with legacy credential passing, proper error propagation, SSL/TLS enforcement, and connection security. Add mock IMAP server fixtures for testing without real server access. Include tests for edge cases: expired tokens, network timeouts, malformed responses. Test the deprecation warning for legacy credential usage. Verify that all authentication mechanisms follow RFC 3501 compliance. Add performance tests for token refresh operations. Document test coverage requirements (aim for >90% coverage of authentication code paths). Include security-focused tests validating that credentials are not logged or exposed in error messages."
        }
      ]
    },
    {
      "id": 10,
      "title": "Implement CLI authentication command",
      "description": "Add the 'auth' command to the CLI for initiating OAuth flows",
      "status": "pending",
      "dependencies": [
        7,
        8
      ],
      "priority": "medium",
      "details": "In `src/cli_v4.py`:\n1. Add a new `auth` command with `--account` parameter\n2. Implement command handler that:\n   - Loads the account configuration\n   - Determines the provider (Google or Microsoft) from the config\n   - Initializes the appropriate OAuth provider\n   - Creates and runs the OAuth flow\n   - Provides clear success/failure messages\n3. Add help text and documentation for the command\n4. Handle error cases gracefully with informative messages",
      "testStrategy": "Write unit tests for the CLI command with mocked OAuth flows. Test with various account configurations. Test error handling for missing or invalid configurations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Add auth command structure with --account parameter and help text",
          "description": "Create the basic Typer command structure in src/cli_v4.py with proper help documentation and parameter validation.",
          "status": "pending",
          "dependencies": [],
          "details": "Use @app.command() decorator to add 'auth' command. Add typer.Option('--account', required=True, help='Account name from config') parameter. Include comprehensive help text: 'Initiate OAuth 2.0 authentication flow for specified account'. Add validation to ensure account exists in config before proceeding. Follow Typer best practices for CLI consistency[1][3]."
        },
        {
          "id": 2,
          "title": "Implement account configuration loading and provider detection",
          "description": "Create config loading logic that reads account settings and determines OAuth provider (Google/Microsoft).",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Load account config using existing config system (likely configparser or YAML). Extract provider field ('google' or 'microsoft') with validation. Raise typer.Exit(code=1, message='Account not found') for missing accounts. Log provider detection for debugging. Handle config file missing/permissions errors gracefully with user-friendly messages."
        },
        {
          "id": 3,
          "title": "Initialize OAuth providers and implement OAuth flow orchestration",
          "description": "Create OAuth provider initialization and flow execution with security best practices.",
          "status": "pending",
          "dependencies": [
            2
          ],
          "details": "Implement provider factory pattern: if provider=='google' → GoogleOAuthProvider(), else MicrosoftOAuthProvider(). Use secure redirect URIs and state parameters to prevent CSRF. Handle both local server callback and manual verification code flows. Store tokens securely (environment vars or encrypted keyring). Implement PKCE for public clients per OAuth 2.0 security best practices."
        },
        {
          "id": 4,
          "title": "Add comprehensive success/failure messaging and error handling",
          "description": "Implement user-facing messages and robust error handling for all failure scenarios.",
          "status": "pending",
          "dependencies": [
            3
          ],
          "details": "Provide clear success: '✅ Authentication successful for {account}! Tokens saved.' Handle specific errors: InvalidClientError, ConsentRequired, NetworkTimeout, etc. Use typer.echo() with emojis for visual clarity. Implement retry logic for transient errors (network timeouts). Gracefully handle Ctrl+C with cleanup. Ensure backward compatibility with V4 error format."
        },
        {
          "id": 5,
          "title": "Add unit tests for auth command components",
          "description": "Create comprehensive test suite covering command invocation, config loading, provider detection, and error scenarios.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Use typer.testing.CliRunner() for end-to-end CLI testing[1]. Mock config loader, OAuth providers, and token storage. Test scenarios: valid account success, missing account, invalid provider, network errors, Ctrl+C interrupt. Verify exit codes (0 success, 1 error) and message patterns. Test --help output. Aim for 90%+ coverage of auth command."
        }
      ]
    },
    {
      "id": 11,
      "title": "Update account processor for OAuth support",
      "description": "Modify the account processor to create the appropriate authenticator based on configuration",
      "status": "pending",
      "dependencies": [
        3,
        9
      ],
      "priority": "high",
      "details": "In `src/account_processor.py`:\n1. Update the code that initializes the IMAP client to:\n   - Read the `auth` block from account configuration\n   - Determine the authentication method (password or OAuth)\n   - Create the appropriate authenticator:\n     - For password: create `PasswordAuthenticator` with email and password\n     - For OAuth: create `OAuthAuthenticator` with email, account name, provider, and TokenManager\n   - Pass the authenticator to the IMAP client\n2. Ensure backward compatibility by defaulting to password authentication if `auth` block is missing\n3. Add appropriate error handling for missing or invalid configurations",
      "testStrategy": "Write unit tests for the account processor with various configurations. Test both password and OAuth authentication methods. Verify backward compatibility with existing configurations. Test error handling for missing or invalid configurations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement configuration parsing for auth block with backward compatibility",
          "description": "Update the account configuration reader to parse the new `auth` block structure while maintaining backward compatibility for existing password-only configs.",
          "status": "pending",
          "dependencies": [],
          "details": "1. Add `auth` field validation to config schema (email, password OR oauth: {account_name, provider, token_manager})\n2. Implement fallback logic: if `auth` missing, construct legacy password auth from `email`/`password` fields\n3. Add `get_auth_config()` method returning dict with `method` ('password'|'oauth') and auth params\n4. Log deprecation warning for legacy password configs\n5. Add unit tests for: valid password config, valid OAuth config, missing auth block fallback, invalid schema"
        },
        {
          "id": 2,
          "title": "Create PasswordAuthenticator and OAuthAuthenticator factory classes",
          "description": "Implement abstract Authenticator base class and concrete implementations for both authentication methods.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "1. Define `Authenticator` abstract base class with `authenticate(imap_client)` method\n2. Implement `PasswordAuthenticator`:\n   - Uses `imap_client.login(email, password)`\n   - Simple error wrapping\n3. Implement `OAuthAuthenticator`:\n   - Uses `imap_client.authenticate('XOAUTH2', self._get_xoauth2_string)` per Microsoft spec[1]\n   - `TokenManager.get_token()` integration for fresh access tokens\n   - SASL XOAUTH2 format: `base64('user={email}\\1auth=Bearer {token}\\1\\1')`[1]\n4. Add `create_authenticator(auth_config)` factory function\n5. Unit test both authenticators with mock IMAPClient"
        },
        {
          "id": 3,
          "title": "Refactor IMAP client initialization to use dynamic authenticator",
          "description": "Replace hardcoded password login with config-driven authenticator selection and execution.",
          "status": "pending",
          "dependencies": [
            1,
            2
          ],
          "details": "1. In `AccountProcessor._connect_imap()`:\n   - Replace `imap.login(email, password)` with `auth_config = self.get_auth_config()`\n   - `authenticator = create_authenticator(auth_config)`\n   - `authenticator.authenticate(self.imap_client)`\n2. Preserve existing IMAPClient instantiation (host, port, ssl config)\n3. Add timeout/retry logic around authentication\n4. Integration test: full IMAP connection flow with both auth types\n5. Verify capabilities check happens AFTER successful authentication"
        },
        {
          "id": 4,
          "title": "Add comprehensive error handling and validation",
          "description": "Implement robust error handling for missing configs, invalid tokens, network issues, and OAuth-specific failures.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Config validation errors: `MissingAuthConfigError`, `InvalidOAuthConfigError`\n2. Authenticator errors: `AuthenticationFailedError` wrapping IMAP exceptions\n3. OAuth-specific: `TokenExpiredError`, `TokenFetchError` from TokenManager\n4. Add `validate_auth_config()` method with specific validation per provider\n5. Graceful degradation: log detailed errors but don't crash processor\n6. Add retry logic for transient OAuth token fetch failures (max 3 attempts)\n7. Integration tests for all error scenarios with pytest.raises()"
        },
        {
          "id": 5,
          "title": "Add end-to-end testing and security validation",
          "description": "Create comprehensive integration tests and validate security best practices implementation.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Integration test suite with mock IMAP server (imaplib2 or aiodns mock)\n2. Test scenarios: password auth, OAuth success, OAuth token expiry/refresh, config errors\n3. Security validation:\n   - Verify no passwords/tokens logged in plaintext\n   - TokenManager refresh called only when needed\n   - XOAUTH2 base64 format correctly implemented per spec[1]\n4. Performance tests: connection time < 10s for both auth types\n5. Backward compatibility test: V4 configs continue working unchanged\n6. Add pytest fixtures for TokenManager and config variants"
        }
      ]
    },
    {
      "id": 12,
      "title": "End-to-end testing and documentation",
      "description": "Perform comprehensive testing and create documentation for the OAuth integration",
      "status": "pending",
      "dependencies": [
        10,
        11
      ],
      "priority": "medium",
      "details": "1. Create end-to-end tests for the OAuth integration:\n   - Test with Google accounts\n   - Test with Microsoft accounts\n   - Test backward compatibility with password accounts\n2. Create documentation for users:\n   - How to set up OAuth credentials in Google and Microsoft developer consoles\n   - How to configure the application with client IDs and secrets\n   - How to authenticate accounts using the CLI\n   - Troubleshooting common issues\n3. Update README.md with information about the OAuth integration\n4. Create example configuration files for Google and Microsoft accounts",
      "testStrategy": "Perform manual testing with real Google and Microsoft accounts. Verify the entire flow works as expected. Test backward compatibility with existing password accounts. Gather feedback on documentation clarity and completeness.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create end-to-end tests for OAuth 2.0 flows with Google and Microsoft accounts",
          "description": "Develop integration tests covering Authorization Code flow with PKCE for Google and Microsoft providers, including token acquisition, refresh, scope validation, and error handling for invalid/expired tokens. Use live test credentials in a staging environment with environment-specific configurations.",
          "status": "pending",
          "dependencies": [],
          "details": "Follow OAuth 2.0 best practices: test correct parameters, failed authorizations, revoked credentials, and protected resource access. Use real provider calls (not mocks) for accurate token validation, rate limits, and edge cases. Structure tests to run across environments with swappable configs[1][2]."
        },
        {
          "id": 2,
          "title": "Create end-to-end tests for backward compatibility with password accounts (V4)",
          "description": "Implement tests verifying seamless fallback to legacy password authentication, mixed OAuth/password sessions, and no regressions in V4 user data access or CLI commands when OAuth is unavailable.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Test token equivalence between OAuth and password flows, ensure backward-compatible session handling, and validate error messages don't expose OAuth internals to V4 users. Include security checks for no unintended scope escalations[1][3]."
        },
        {
          "id": 3,
          "title": "Create user documentation for OAuth setup and CLI authentication",
          "description": "Write comprehensive guides covering Google/Microsoft developer console setup, application configuration with client IDs/secrets, CLI authentication commands, and security best practices like PKCE and token binding.",
          "status": "pending",
          "dependencies": [
            1
          ],
          "details": "Include step-by-step instructions with screenshots, environment variable examples, and warnings about secret management. Cover OAuth 2.0 flows used and CLI syntax for `login --provider google` etc. Emphasize RFC 6819 threat mitigations[3][4]."
        },
        {
          "id": 4,
          "title": "Create troubleshooting documentation and example configuration files",
          "description": "Document common issues (redirect URI mismatches, scope errors, token expiration) with solutions, and provide sample config files for Google/Microsoft OAuth with secure defaults.",
          "status": "pending",
          "dependencies": [
            3
          ],
          "details": "Configs should demonstrate client ID/secret placement, required scopes, and PKCE parameters. Troubleshooting section includes logs to check, API error codes, and recovery steps. Use YAML/JSON formats matching app expectations[1][4]."
        },
        {
          "id": 5,
          "title": "Update README.md with OAuth integration information",
          "description": "Add dedicated OAuth section to README.md summarizing quickstart, supported providers, backward compatibility notes, security considerations, and links to full documentation.",
          "status": "pending",
          "dependencies": [
            3,
            4
          ],
          "details": "Keep concise: installation prerequisites, one-command setup, migration guide from V4, and security warnings (rotate secrets, use HTTPS). Include badges for tested providers and version compatibility matrix[3]."
        },
        {
          "id": 6,
          "title": "Run comprehensive test suite and validate all documentation",
          "description": "Execute full end-to-end test suite across all providers/environments, fix any failures, then review all documentation for accuracy against test results and best practices.",
          "status": "pending",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Verify tests pass in CI pipeline with observability (log requests/responses safely). Cross-check docs against real flows, update with any new edge cases found. Confirm security: RS256/ES256 signing, no hardcoded secrets[1][2][3][4]."
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "PRD Implementation",
    "totalTasks": 12,
    "sourceFile": "c:\\Users\\Marc Bielert\\Github\\email-agent\\scripts\\prd_v5_combined.txt",
    "generatedAt": "2023-11-13"
  }
}